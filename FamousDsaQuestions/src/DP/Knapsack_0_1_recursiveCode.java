package DP;

import java.util.Scanner;

public class Knapsack_0_1_recursiveCode {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.println("Enter max capacity of bag ");
		int bagMaxWt = sc.nextInt();
		System.out.println("Enter number of elements in bag ");
		int numberOfEle = sc.nextInt();
		int wt[] = new int[bagMaxWt];
		int val[] = new int[numberOfEle];// val is value/cost/profit of each item
		for (int i = 0; i < numberOfEle; i++) {
			System.out.println("Enter weight and val of " + i + " item:");
			wt[i] = sc.nextInt();
			val[i] = sc.nextInt();
		}
		
		System.out.println("wt val");
		for(int i=0;i<numberOfEle;i++) {
			System.out.println(wt[i]+" "+ val[i]);
		}
		
		
		System.out.println("Max profit is : " + knapsack(wt, val, numberOfEle - 1, bagMaxWt));// numberOfEle - 1 cause
																								// otherwise it will
																								// give array out of
																								// bound error
	}

	public static int knapsack(int wt[], int val[], int currEle, int currLeftCapacityOfBag) {// we start from end of the
																								// array "wt" and "val"
																								// and keep
																								// reducing its size by
																								// moving the pointer
																								// "currEle" which goes
																								// from n-1 to 0 where n
																								// is size of array and
																								// meanwhile we decide
																								// whether to include
																								// current element or
																								// not

		if (currEle == -1 || currLeftCapacityOfBag == 0) {// base case , base case is simple , since we moving from
															// n-1(n=length of array) to
															// 0 means one base case would be that no item left to
															// choose from i.e. we traversed them all (i.e. currEle
															// reached to -1) in which case current ele cannot
															// generated any profit cause theres nothing left to pick
															// from so return 0 and another case can
															// be that current capacity left in bag is 0 again we can't
															// add
															// the current element even if it increases the profit cause
															// theres
															// no space left in bag so again return 0 cause current ele cant add anything to the overall solution
			return 0;
		}

		if (wt[currEle] <= currLeftCapacityOfBag) {// weight of current ele is less than or equal to current capacity of
													// bag means we can choose this element , now we have 2 choice
													// whether to include it or exclude it

			return Math.max(knapsack(wt, val, currEle - 1, currLeftCapacityOfBag - wt[currEle]) + val[currEle],
					knapsack(wt, val, currEle - 1, currLeftCapacityOfBag));// we need max of the max profit that can be
																			// generated by either including current
																			// element in answer or excluding it , if
																			// current element included so decrease
																			// the capacity of bag left and add the
																			// profit generated from it and tell
																			// recursion to give me result of other
																			// items that are left i.e. tell recursion to decide which item to include
																			// and which to exclude from the remaining item , just give me the max profit ,  this is
																			// the leaf of faith on recursion , and if
																			// you are not including current element
																			// simply tell recursion to go give me max
																			// profit generated by remainig items

		} else {// this means that weight of current element is bigger than the capacity left in
				// bag so simply it means don't include it and move on 
			return knapsack(wt, val, currEle - 1, currLeftCapacityOfBag);
		}

	}

}













